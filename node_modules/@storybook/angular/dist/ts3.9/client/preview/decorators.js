"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.componentWrapperDecorator = exports.moduleMetadata = void 0;
const ComputesTemplateFromComponent_1 = require("./angular-beta/ComputesTemplateFromComponent");
const NgComponentAnalyzer_1 = require("./angular-beta/utils/NgComponentAnalyzer");
// We use `any` here as the default type rather than `Args` because we need something that is
// castable to any component-specific args type when the user is being careful.
exports.moduleMetadata = (metadata) => (storyFn) => {
    const story = storyFn();
    const storyMetadata = story.moduleMetadata || {};
    metadata = metadata || {};
    return Object.assign(Object.assign({}, story), { moduleMetadata: {
            declarations: [...(metadata.declarations || []), ...(storyMetadata.declarations || [])],
            entryComponents: [
                ...(metadata.entryComponents || []),
                ...(storyMetadata.entryComponents || []),
            ],
            imports: [...(metadata.imports || []), ...(storyMetadata.imports || [])],
            schemas: [...(metadata.schemas || []), ...(storyMetadata.schemas || [])],
            providers: [...(metadata.providers || []), ...(storyMetadata.providers || [])],
        } });
};
exports.componentWrapperDecorator = (element, props) => (storyFn, storyContext) => {
    const story = storyFn();
    const currentProps = typeof props === 'function' ? props(storyContext) : props;
    const template = NgComponentAnalyzer_1.isComponent(element)
        ? ComputesTemplateFromComponent_1.computesTemplateFromComponent(element, currentProps !== null && currentProps !== void 0 ? currentProps : {}, story.template)
        : element(story.template);
    return Object.assign(Object.assign(Object.assign({}, story), { template }), (currentProps || story.props
        ? {
            props: Object.assign(Object.assign({}, currentProps), story.props),
        }
        : {}));
};
